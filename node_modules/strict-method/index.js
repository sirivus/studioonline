module.exports = strictmethod;
var typeOf = require("./type");
var converters = require("./converters");
var validaters = require("./validaters");

strictmethod.Arguments = Arguments;

strictmethod.ParamError = ParamError;

function ParamError(msg){
    this.name = "ParamError";
    this.message = msg;
}

function Arguments(){
    throw new ParamError("only label, cann't call.")
}

function strictmethod(){

    var  argsLen
        ,lastParam = arguments[arguments.length-1]
        ,j=0
        ,dumb = false
        ,functionBody;
        
    if(lastParam === true || lastParam === false){
        functionBody = arguments[arguments.length-2];
        argsLen = arguments.length-2;
        dumb = lastParam;
    }else{
        functionBody = arguments[arguments.length-1];
        argsLen = arguments.length-1;
    }
    
    var types = [];
    var validateParams = [];
    for(var i= 0;i<argsLen;){
        if(isType(arguments[i])){
           types.push(arguments[i]);
           if(i+1<argsLen){
               if(!isType(arguments[i+1])){
                  validateParams[j] = arguments[i+1];
                  i+=2;
               }else{
                  i+=1;
               }
           }else{
               i+=1;
           }
           j+=1;
        }else{
           throw new ParamError("params error.")
        }
    }

    function wrap(){
        var args = [];
        var haveError = false;

        for(var i=0 ; i<j ; i++){
  
           var arg = arguments[i];
           var type = types[i];
           var validateParam = validateParams[i];
           var validater = getValidation(type);
        
           if(!arg && validateParam && validateParam.default){
               arg = validateParam.default;
               delete validateParam.default;
           }
           try{

               if(coreTypeValidate(arg,type) || arg instanceof type){
                       args.push(arg);
               }else{
                   var converter = getConverter(type);
                   if(converter){
                       arg = converter(arg);
                       if(arg === undefined){
                           throw new ParamError("argument "+i+" type error");
                       }
                       args.push(arg);
                   }else{
                       throw new ParamError("argument "+i+" type error");
                   }
               }
               
               if(validateParam && validater){
                    
                    if(validater(arg,validateParam) === false){
                          throw new ParamError("validat error");
                    }
               }

           }catch(e){
                if(dumb){
                    return e;
                }else{
                    throw e;
                }
           }
        }
        
        // Add other avgs push to args.
        if(j<arguments.length){
            // other avgs.
            var otherAvgs = [].slice.call(arguments,j,arguments.length);
            args = args.concat(otherAvgs);
        }
        return functionBody.apply(this,args);
        
    }

    // extend static property.
    for(var k in functionBody){
        wrap[k] = functionBody[k];
    }
    
    // extend prototype.
    wrap.prototype = functionBody.prototype;
    
    wrap.prototype.constructor = functionBody;
    
    return wrap;
}

strictmethod.converter = function(type,cter){
     if(!getConverter(type)){
         converters.push({type:type,converter:cter});
     }
}

strictmethod.validater = function(type,vter){
     if(!getValidation(type)){
         validaters.push({type:type,validater:vter});
     }
}

function isType(type){
    return type instanceof Function;
}

function getConverter(type){
    var cvter;
    converters.forEach(function(cvt){
        if(cvt.type === type){
            cvter = cvt.converter;
        }
    })
    return cvter;
}

function getValidation(type){
    var vter;
    validaters.forEach(function(vt){
        if(vt.type === type){
            vter = vt.validater;
        }
    })
    return vter;
}

function coreTypeValidate(o,type){

    switch(type){

        case Arguments:
            return typeOf(o) === "arguments";
            break;
        case Function:
            return typeOf(o) === "function";
            break;
        case Date:
            return typeOf(o) === "date";
            break;
        case Object:
            return typeOf(o) !== "undefined";
            break;
        case String:
            return typeOf(o) === "string";
            break;
        case Boolean:
            return typeOf(o) === "boolean";
            break;
        case RegExp:
            return typeOf(o) === "regexp";
            break;
        case Array:
            return typeOf(o) === "array";
            break;
        case Number:
            return typeOf(o) === "number";
            break;

    }
}
