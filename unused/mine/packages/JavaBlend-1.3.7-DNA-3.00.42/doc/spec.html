<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>${project.title} - Documentation</title>
		<!-- standard meta data -->
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="author" content="Holger Machens">
		<meta name="date" content="${system.datetime}">
		<!-- meta data for search engines -->
		<meta name="description" content="${project.description}">
		<meta name="keywords" lang="en" content="${project.keywords}">
		<!-- meta name="robots" content="noindex,nofollow"-->
</head>
<body>
<h1 style="text-align: center">Java .Blend</h1>
<h2 style="text-align: center"><b>Documentation</b></h2>
<p style="text-align: center">Version ${project.version}</p>
<p style="text-align: center">${system.date}</p>
<p style="text-align: center">Holger Machens</p>



<p>
This is the documentation of the <a href="index.html">Java .Blend</a> generic Blender 
file import/export toolkit for Java.
Blender is an open source 3D graphics modelling and rendering environment which supports import and
export of various file formats such as FBX and Collada. Imports and exports always require
a mapping between different formats which inevitably involves compromises, resulting in 
loss of information. Java .Blend aims to fill the gap for Java programmers, who want 
type-safe access to all the data in a Blender file with read <b>and</b> write capabilities. 
To achieve that, Java .Blend uses meta data which is contained in each Blender file, 
and describes Blender's entire core data model. This meta data is fed to Java .Blend's 
code generator, which generates Java classes for all types in Blender's data model and 
thereby creates a type-safe API to access raw data in a <code>.blend</code> file. Thus, 
there are no gaps in the model and every piece of a Blender file is available to the 
API programmer.
</p>
<p>
This document contains a system specification of Java .Blend. 
It describes its functionality and specifies its data model. 
To understand the system specification, and to work with Blender files,
a basic knowledge of Blender's data model and its file format is necessary. Therefore, 
this document starts with an introduction to Blender's DNA and its file format. The 
section thereafter covers the system specification which involves vital information 
on the type mapping between C structs and types in Blender and Java classes 
and types in Java .Blend. It also explains main parts of the Java .Blend runtime 
library (data I/O). More detailed information on parts of the system can be found 
in the Javadoc documentation (respective the source code documentation). At the 
end of this document there is a brief getting started guide for API programmers. 
Main purpose of this section is to point programmers in the right direction. 
The <a href="demo/index.html">examples</a> found in the <a href="index.html#download">download section</a> of the website are intended to 
help further down the road.
</p>
<h1>Contents</h1>
<table>
<tr><td></td><td><b><a href="#BlenderDNA">Blender DNA</a></b>
	<table>
	<tr><td></td><td><b><a href="#DNADataModel">Brief Data Model Overview</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#BlenderFormat">Blender File Format</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#AddressMapping">Blender Address Mapping</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#FileVersion">Blender Versioning and File Version</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#BlockOrder">Block Order</a></b>
	</td></tr>
	</table>
</td></tr>
<tr><td></td><td><b><a href="#Concept">Concept</a></b>
	<table>
	<tr><td></td><td><b><a href="#DesignOverview">Design Overview</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#BlockLevelIO">Block Level I/O</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#TypeMapping">Type Mapping</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#CodeGenerator">Code Generator</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#Facades">Generated Facade Classes</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#Utilities">Generated Utilities Package</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#Documentation">Externally Maintained Documentation</a></b>
	</td></tr>
	</table>
</td></tr>
<tr><td></td><td><b><a href="#GettingStarted">Getting Started</a></b>
	<table>
	<tr><td></td><td><b><a href="#Setup">Setup</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#Reading">Reading</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#Writing">Writing</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#ContributeDoc">Contributing to Documentation</a></b>
	</td></tr>
	<tr><td></td><td><b><a href="#GeneratingCode">Generating Data Model and Utilities</a></b>
	</td></tr>
	</table>
</td></tr>
</table>

<h1 id="BlenderDNA">Blender DNA</h1>
<p>
Blender's core data model is called its DNA. It covers all relevant, persistent data of a 
running Blender process which will be stored in a file. Data is stored in a <code>.blend</code> file 
as plain images of the data structures in heap memory. Thus, the data model in the file is exactly the 
same as in heap memory. Therefore, understanding Blender's DNA is the first part of 
understanding the Blender file format. The following section is intended to provide a brief 
introduction to the fundamental design principles of the Blender DNA but it does not
cover the whole data model.
</p>
<h2 id="DNADataModel">Brief Data Model Overview</h2>
<p>
Blender organises all data in so called libraries. A library holds references on 
the content of one file. A library is either classified as a <code>Main</code> 
library, which holds the content of one <code>.blend</code> file, or a common 
<code>Library</code>, which holds the content of an external file, such as a texture image. 
</p>
<p style="text-align: center"><img src="images/dna-main.png"/></p>
<p>
Main libraries (see Figure above) hold references on the main library elements such as a <code>Scene</code>,
<code>Object</code>s of a scene, <code>Mesh</code>es, <code>Material</code> and so on but not
on detailed data such as vertices or normals of a mesh. Those details are referenced by 
the main library elements themselves (see Figure below).
</p>
<p style="text-align: center"><img src="images/dna-mesh.png"/></p>
<p>
Further down, main library elements have references between each other 
to establish a scene graph (see Figure below).
</p>
<p style="text-align: center"><img src="images/dna-scene.png"/></p>

<h2 id="BlenderFormat">Blender File Format</h2>
<p>
On its lowest level, a Blender file consists of a header followed 
by a list of blocks of memory. Each block holds data of a specific type,
such as a struct an array of structs or single data elements. 
One of the blocks contains the type information required to interpret 
the body of a block.
<h3 id="FileHeader">File Header</h3>
<p>
The file header (first 12 bytes of every Blender file) contains 
low-level information about the file:
</p>
<table border="1">
<tr>
  <th>name</th><th>type</th><th>description</th>
<tr>
<tr>
  <td>MAGIC</td><td>7 byte ASCII</td><td>Content: "BLENDER". Used to identify Blender files</td>
<tr>
<tr>
  <td>pointerSize</td><td>1 byte ASCII</td><td>Indicates the width of an address (i.e. <code>sizeof(void*)</code> which is the same as <code>sizeof(long)</code>). '_' means 4 bytes and '-' means 
	 8 bytes.</td>
<tr>
<tr>
  <td>byteorder</td><td>1 byte ASCII</td><td>Byte ordering used in the file. 'v' means little endian and 'V' means big endian.</td>
<tr>
<tr>
  <td>version</td><td>3 byte ASCII</td><td>Blender version the file originated from. "234" means version 2.34 .</td>
<tr>
</table>
<p>
As you can see, all the data given in the header is represented in single bytes and therefore 
independent of byte order and address width of the underlying system architecture. All subsequent data 
following after the file header may require conversion to the data representation of the runtime environment, present.
</p>


<h3>Block Level</h3>
<p>
Blocks consist of a header, which describes what type of data is stored in its
body, and a body with the actual data. The block header always starts at a file 
position which is 4 byte aligned. The body always contains data of 
one specific type, which is either a struct, an array of structs or scalars or even
single scalar elements.
</p>
<table border="1">
<tr>
  <th>name</th><th>type</th><th>description</th>
<tr>
<tr>
  <td>code</td><td>4 byte ASCII</td><td>The block code gives a rough indication of 
  which purpose the data is. Main library elements always have a dedicated block code 
  such as <code>"SC"</code> for structs of type <code>Scene</code> or <code>"ME"</code> 
  for structs of type <code>Mesh</code>. The most important codes are <code>"DNA1"</code> which contains the 
  type information required to interpret any data in all the remaining blocks, and <code>"ENDB"</code>
  which marks the end of the file. </td>
<tr>
<tr>
  <td>size</td><td>int32</td><td>Length of the body in bytes.</td>
<tr>
<tr>
  <td>address</td><td><em>&lt;pointerSize&gt;</em></td><td> 
  This is the address, the data was found in memory, when it 
  was stored to disk. This information is required to restore 
  pointers on data in this block. Please note: <em>&lt;pointerSize&gt;</em> 
  refers to the pointer size given in the file header.</td>
<tr>
<tr>
  <td>sdnaIndex</td><td>int32</td><td>This is an index into the 'struct' array in 
  the type information. It defines the type of struct to be found in the body. 
  Please note that <code>sdnaIndex==0</code> is ambiguous. It can either stand for 
  struct <code>LinkBase</code> or data of unknown type (e.g. an array of int). 
  In the latter case, type of data can be determined from pointers that 
  refer to it or from the context.</td>
<tr>
<tr>
  <td>count</td><td>int32</td><td>This is the number of instances of the 
  type specified by 'sdnaIndex', stored in this block.</td>
<tr>
</table>
<p>
Since each block has its original memory address stored, it is possible 
to restore pointers on data in blocks. But there are cases, where the 
pointer addresses memory which is not in the file, too.
</p>

<h3 id="DNATypeInformation">Type Information</h3>
<p>
All type information is stored in the block with code <code>"DNA1"</code>, which 
can be at any position in the file. DNA1 contains a C structure
called <code>StructDNA</code> or Structure DNA, which contains the
type information.
</p>
<table border="1">
<tr>
  <th>name</th><th>type</th><th>description</th>
<tr>
<tr>
  <td>SDNA</td><td>4 byte ASCII</td><td>Content: "SDNA". Indicates start of the StructDNA struct.</td>
<tr>
<tr>
  <td>NAME</td><td>4 byte ASCII</td><td>Content: "NAME". Indicates start of the field name list section (see below).</td>
<tr>
<tr>
  <td>names_len</td><td>int32</td><td>Array length of the following field 'names'.</td>
<tr>
<tr>
  <td>names</td><td>Array of null terminated ASCII strings</td><td>This array contains the names of 
  the fields of all structs. A name consists of the actual name of the field and type specifications, 
  such as if it is a pointer or an array (e.g. "*points[10]").</td>
<tr>
<tr>
  <td>TYPE</td><td>4 byte ASCII</td><td>Content: "TYPE". Indicates start of the field type list section (see below).</td>
<tr>
<tr>
  <td>types_len</td><td>int32</td><td>Array length of the following field 'types'.</td>
<tr>
<tr>
  <td>types</td><td>Array of null terminated ASCII strings</td><td>This array contains the names of all types (scalar and structured) possibly used in any Blender file of that version. A type name contains the basic type only, such as <code>int</code>, <code>char</code> or <code>LinkBase</code>, <code>Object</code>, etc.</td>
<tr>
<tr>
  <td>TLEN</td><td>4 byte ASCII</td><td>Content: "TLEN". Indicates start of the type length section (see below).</td>
<tr>
<tr>
  <td>type_lengths</td><td>int16[&lt;types_len&gt;]</td><td>An array, which contains 
  for each type listed in 'types' above, the length of the type in bytes (e.g. 4 for 
  <code>int</code> or 32 for <code>LinkBase</code>).</td>
<tr>
<tr>
  <td>STRC</td><td>4 byte ASCII</td><td>Content: "STRC". Indicates start of the struct 
  type information section (see below).</td>
<tr>
<tr>
  <td>structs_len</td><td>int32</td><td>Length of the following array field 'structs'</td>
<tr>
<tr>
  <td>structs</td><td>Array of Struct instances</td><td>This is the array, which contains 
  		the type information for any struct possibly used in a Blender file of the given 
  		version. Each element of the array contains an instances of a struct with the 
  		type information for a given struct.
  <br/>For each struct:
  <table border="1">
	<tr>
	  <th>name</th><th>type</th><th>description</th>
	<tr>
	<tr>
	  <td>type</td><td>int16</td><td>Index in field 'types', giving the name of the struct.</td>
	<tr>
	<tr>
	  <td>fields_len</td><td>int16</td><td>Length of the following array field 'fields'.</td>
	<tr>
	<tr>
	  <td>fields</td><td>Field[]</td><td>Array of instances of type Field containing 
	  descriptions for each member field of the struct.<br/>For each field:
	  <table border="1">
		<tr>
		  <th>name</th><th>type</th><th>description</th>
		<tr>
		<tr>
		  <td>type</td><td>int16</td><td>Index in field 'types' to receive the type of the field.</td>
		<tr>
		<tr>
		  <td>name</td><td>int16</td><td>Index in field 'names' to receive the name of the field.</td>
		<tr>
	  </table>
	  </td>
	<tr>
  </table>
  </td>
<tr>
</table>
<h2 id="AddressMapping">Blender Address Mapping</h2>
<p>
Since all data of a Blender process is stored without any conversion, all pointers in 
structs will still reference addresses in the memory of the original process. When 
Blender loads a file, data will get a different address in the new process and 
all pointers in that data have to be adjusted to point to the new location. 
For the most part, blender uses a so-called <code>oldnewmap</code> which 
maps old start addresses to new start address.
</p>
<p>Please note, that the start address of a block is guaranteed to be unique but 
the content may or may not overlap the address space of following blocks. 
As explained, most of the blocks contain data which originates from the heap
of the blender process which created the file. In a healthy application, memory 
areas on heap do not overlap each other. Accordingly, all addresses referring to data 
inside of any of those areas stored in a block are unique as well. However, there 
are a few exceptions since not all of the blocks existed in heap memory in the 
form they are written to the file. One example is a tree structure which is 
written to the file as a list to get a more compact format. The start address of the block
which contains the tree elements is artificial and does not correspond to an actual address
on heap. Blender guarantees that the start address is unique, but the address range
represented by the data in this block (i.e. the range <code>]start, start+length]</code>) 
may or may not overlap the address range of other blocks.
</p>

<h2 id="FileVersion">Blender Versioning and File Version</h2>
<p>
Blender differentiates between Blender program version (referred to as Blender version) 
and Blender file version. This section clarifies the meaning and relationship of both version specifiers. 
</p>
<p>
On release, both types of version specifiers are comprised of three numbers which have different meanings:
</p>
<ul>
<li>Major version: This number is currently, internally limited to a single digit. It changes based on 
marketing or political decisions, which is rare for the time beeing.</li>
<li>Minor version: This number is internally limited to two digits. Unless the major number 
has been changed, this number counts up with every official release.</li>
<li>Patch version: This is also referred to as <i>sub-version</i>. Once released, a given Blender version gets maintenance support. 
This number changes when bug fixes have been incorporated. This number is abritrary long.</li>
</ul>
<p>
Beyond that, there is also a version cycle specifier, which reflects different stages in the development process, such as
<i>alpha</i>, <i>beta</i>, release candidate (<i>rc</i>) and finally <i>release</i>. 
However, any officially released version (including patch releases) has the version cycle specifier <i>release</i>, 
which is why it can be ignored here.
</p>

<p>
As initially mentioned, Blender developers have decided to separate versioning of the Blender program code 
and the Blender file format.
</p>
<ul>
<li>Blender Version: The Blender program version, or Blender version for short, refers to the version of alle that code, 
    which makes up the Blender program except of the code, which is related to the file format.</li>
<li>Blender File Version: The Blender file version refers to the version of the file format, the data model behind it 
(so-called DNA) and the associated code, which is responsible to read, write files and provide access to the DNA in memory, 
inside of a running Blender program instance. So, one can think of the DNA to be a module, which is added to the program code and
therefor has its own versioning. </li>
</ul>
<p>
To keep track of the relationship between Blender version and Blender file version, both version numbers will always have the same
major and minor number. Thus, a Blender program of version 2.91.x will always create files of file version 2.91.y, where x and y can be different. 
</p>
<p>
Blender generally allows to read older version Blender files into a newer version Blender program. This requires Blender 
to have the code to migrate the DNA stored in an older version file into a new version DNA. To some degree, Blender can also
migrate backwards, which means that a Blender program of an older version can read a Blender file of a newer version. However, 
this works only in a limited version range and this range is specified by two file version: The actual file version 
and the so-called 'minimal' version. Below is the comment in the code, which states that. Blender achives that by 
storing the actual layout of each struct and offsets of their properties in each blender file in the block DNA1.
</p>

<pre>
/* Blender major and minor version. */
#define BLENDER_VERSION 291
/* Blender patch version for bugfix releases. */
#define BLENDER_VERSION_PATCH 0
/** Blender release cycle stage: alpha/beta/rc/release. */
#define BLENDER_VERSION_CYCLE release

/* Blender file format version. */
#define BLENDER_FILE_VERSION BLENDER_VERSION
#define BLENDER_FILE_SUBVERSION 10

/* Minimum Blender version that supports reading file written with the current
 * version. Older Blender versions will test this and show a warning if the file
 * was written with too new a version. */
#define BLENDER_FILE_MIN_VERSION 290
#define BLENDER_FILE_MIN_SUBVERSION 0
</pre>

<p>
The version specifier given in the file header of a Blender file always refers to the
version of the Blender program instance, which created the file. Besides this information, a Blender
file contains a block called <code>GLOB</code>, which contains more detailed information 
in respect to DNA model compatibility, based on additional version specifiers.
This block contains the struct <code>FileGlobal</code>.
</p>
<p>
A full version check in Blender considers these four version specifiers:
</p>
<dl>
<dt>VERSION (file header)</dt>
<dd>This is the version of the Blender instance, which created the file. This 
version specifier contains the major and the minor version number.</dd>
<dt>SUBVERSION (FileGlobal)</dt>
<dd>This is a version extension to the <code>VERSION</code>. A subversion number 
is Blender's equivalent to a build number. Thus, the full version specifier of 
the Blender instance would be a concatenation of <code>VERSION</code> and 
<code>SUBVERSION</code>.</dd>
<dt>MINVERSION (FileGlobal)</dt>
<dd>This version specifier refers to the minimal version, this file will 
be model-equivalent to. Which means, that the Blender DNA in version <code>VERSION</code>
still contains all structs and member variables of structs to cover all data given in
<code>.blend</code> files starting from <code>MINVERSION</code> up to <code>VERSION</code>.
</dd>
<dt>MINSUBVERSION (FileGlobal)</dt>
<dd>This is a version extension similar to <code>SUBVERSION</code> (i.e. 
build number of the first version, which had the same DNA). </dd>
</dl>

<p>
Based on this information a system can consider a given file to be compatible with Blender 
in a version starting from <code>MINVERSION, MINSUBVERSION</code> up to 
<code>VERSION, SUBVERSION</code>. This does not mean, that the DNA has not changed 
during this period. It just means that all structs and member variables present at 
<code>MINVERSION</code> are still available in version <code>VERSION</code>. Structs 
can be added, member variables can be added to existing structs, types of member variables
can change and even the semantic of data can change. Thus, reading a file of one version
which is considered compatible, but not of the same version as the current DNA, is subject to
several conversion procedures before it is available to the system. Those conversion procedures
can be found in blenders source code in files 
<code>source/blender/blenloader/intern/versioning_*.c</code>. Java .Blend does not implement these
conversion function, and instead expects the user to use an exact matching library version for 
their Blender version.
</p>

<h2 id="BlockOrder">Block Order</h2>
<p>
Blocks stored in a Bender file follow a specific order. 
The common rule for blocks stored in a Blender file is, that 
referenced <code>DATA</code> blocks always have to be placed behind the 
specified block of a main library element, which references it, and before the next 
main library element.
</p>
<p>
The following list summarises all block order related rules:
</p>
<ul>
<li>Main library elements are always immediately followed by the <code>"DATA"</code> blocks with
their associated detailed data. Main library elements cannot be placed between those 
<code>"DATA"</code> blocks of another main library element. For example, a block with code <code>"ME"</code> containing struct <code>Mesh</code> 
is followed by its <code>"DATA"</code> blocks with arrays of <code>MVert</code>, <code>MLoop</code>, <code>MEdge</code> 
and so on. The next main library block will appear after the last <code>"DATA"</code> block of the previous main library element. 
</li>
<li>The block <code>"DNA1"</code> (see <a href="#DNATypeInformation">Type Information</a>) can be placed anywhere in the file before the 
<code>ENDB</code> block, but not between <code>"DATA"</code> blocks of a 
main library element or the main library element and its <code>"DATA"</code> blocks.</li>
<li>The <code>"GLOB"</code> block can be placed anywhere before the <code>"ENDB"</code>, 
but it has to respect the relationship between main library elements and their data, too.</li>
<li>At the end of the file, there is a single Block with code <code>"ENDB"</code>.</li>
</ul>


<h1 id="Concept">Concept</h1>
<h2 id="DesignOverview">Design Overview</h2>
<p>
This section gives a brief overview of the general concept behind Java .Blend.
</p>
<h3 id="Modules">Modules</h3>
<p style="text-align: center"><img src="images/model-generator.png"/></p>
<p>
Java .Blend basically consists of two modules:
</p>
<dl>
<dt>Model Generator</dt> 
<dd>The model generator (see image above) is a code generator, 
which generates Java code according to the meta data found in a 
reference Blender file. The generated code comprises a data model 
which reflects the <a href="#DNADataModel">Blender DNA</a>. This generated 
data model consists of facades with getter and setter methods to access native data 
in heap memory at runtime.
</dd>
<dt>Runtime Data I/O</dt> 
<dd>Random access to native data of a 
Blender file is provided by the data I/O sub-module (see image below) which is 
working behind the scenes at runtime. It is responsible to transfer data between file and heap memory and
supports facades of the data model in address translation, type 
conversion and data access in general. Please note, that Java .Blend 
does not include code for conversion between different DNA versions. 
</dd>
</dl>


<p style="text-align: center"><img src="images/facade.png"/></p>
<p>
To summarise: Based on the type information (see <a href="#DNATypeInformation">Type Information</a>) 
of any reference Blender file, the model generator generates a data model in 
terms of facades which provide type-safe access to native Blender data. 
The generated data model in combination with the runtime data I/O module 
is used at runtime to access data of any Blender file of the same version.
Native Blender data is kept in its format in heap memory and accessed through 
the facades getter and setter methods. Life cycle of native data is implicitly 
covered by the Java VMs garbage collection. 
</p>
<h3 id="Method">Method</h3>
<p>
At development time, the model generator is used to generate a 
data model for a particular Blender version, based on any 
<code>.blend</code> file created by Blender. The Java classes
of the data model can be generated into a
source folder of a specific project or compiled and archived in 
a separate Java library (<code>.jar</code>), to be used in 
multiple projects.
</p>

<p>
<b>Example</b>
</p>
<pre>
	java -jar JavaBlend.jar -out "../myproject/src" -p "my.package.blender" -in "any-file.blend"
</pre>
<p>
Once the data model is generated, it can be used in combination with the 
runtime data I/O module to access any <code>.blend</code> file of the
same Blender version. The application opens a Blender file and instantiates
a <code>MainLib</code> library (see <a href="">Blender DNA</a>). 
The example below shows a use case, where an application opens a 
Blender file and reads the polygons of a mesh.
</p>
<p>
<b>Example</b>
</p>
<pre>
	//
	// Open file and retrieve main lib
	//
	BlenderFile f = new BlenderFile("cube.blend");
	MainLib main = new MainLib(f);
	f.close();
	
	//
	// retrieve the first mesh's polygons
	//
	Mesh mesh = lib.getMesh();
	MPoly[] polygons = mesh.getMpoly().toArray(mesh.getTotpoly());
</pre>
<p>
<em>More comprehensive examples involving materials and textures can be 
found in the <a href="http://homac.cakelab.org/projects/JavaBlend/index.html#download">download 
section of the website</a>.</em>
</p>

<h2 id="BlockLevelIO">Block Level I/O</h2>
<p>
On the lowest level, the runtime I/O package has to deal with 
blocks and mapping of addresses to offsets in blocks 
(see package <code>org.cakelab.blender.io</code>). All data of a 
model stored in a Blender file is kept in its native 
format and converted on demand. 
</p>
<h3 id="AddressResolution">Address Resolution Concept</h3>
<p>
For all blocks which contain data originating from heap, 
address mapping is straight forward: Lookup the block with 
a start address less or equal to the address which has to 
be resolved and whose length is large enough to contain the address.
</p>
<h4 id="OffheapAreas">Offheap Areas</h4>
<p>
As explained in Section <a href="#AddressMapping">Blender Address Mapping</a> a .blend file can contain blocks
whose address range may or may not overlap the address range of other blocks. 
Since the data did not originate from its original location on the heap of the blender process which created the file,
we call the corresponding memory area <em>Offheap Areas</em>. 
The general rule for blocks in offheap areas is, that only their start address
is guaranteed to be unique. Luckily, only certain types of data are stored in offheap 
areas. Thus, we can differentiate between on-heap and offheap areas based on the 
type of data which is referenced (also stored in the block header) 
and apply the proper address resolution routine.
</p>
<p>
The types of blocks, which originated from offheap areas may change with different 
versions of blender. Thus, the I/O subsystem contains a lookup table with lists of 
struct names to be found in offheap areas for different blender versions (see package <code>org.cakelab.blender.versions.OffheapAreas</code>).
</p>
<p>
In case a .blend file contains blocks which overlap each other and whose struct 
types are not listed in the offheap areas, the block table will throw an exception
during initialisation. This exception provides a list of the overlapping blocks and
their struct types. This information is needed to fix the issue.
</p>
<p>To fix an issue with overlapping blocks, you need to adapt the list of types 
from offheap areas to the given blender version. Simply add a new entry in class 
<code>org.cakelab.blender.versions.OffheapAreas</code> and run the code generation again.
Entries for offheap areas consist of a blender version number followed by a list of 
struct type names of blocks, which have been found to overlap other blocks in the given blender version.
</p>
<pre>
		map.add(new Entry(280, new String[]{"FileGlobal", "TreeStoreElem"}));
</pre>
<p>
To identify the type of data which should be moved to an offheap area, you can use the information 
given by the OverlappingBlocksException you have received. Try to identify the type which solves 
the most overlap conflicts at once when moved off heap and add it to the list of your new offheap area entry.
<b>Important:</b> Offheap areas cannot contain the type <code>LinkBase</code> (sdna index: 0) 
because it is used for raw data as well (i.e. untyped). 
</p>
<p>Afterwards, run the code generation again, add the new code to your project 
and read the file again to test it. Another approach is off course to study the blender source 
code and identify the actual structure, which causes the issue ;) </p>


<h3 id="BlenderFile">Class BlenderFile</h3>
<p>
<code>BlenderFile</code> is the main class to start working with a Blender file.
It controls reading and writing of Blender files and keeps 
references on essential objects, such as block table and 
block list (see below).
</p>
<p>
When creating new Blender files, this class is also responsible 
to initialise the file with essential data, such as header, end block
and a block with type information (<code>StructDNA</code>, see Section <a href="#DNATypeInformation">Type Information</a> 
and Section <a href="#StructDNA">StructDNA</a>). This class does not
create the required <code>StructDNA</code> on its own. 
Please refer to the <a href="#BlenderFactory">Blender Factory</a> 
to retrieve a generated <code>StructDNA</code>.
</p>
<p>
When finally writing a created Blender file, this class adds the fundamental blocks <code>DNA1</code>,
<code>GLOB</code> and <code>ENDB</code> at their proper locations (see <a href="#BlockOrder">Block Order</a>).
</p>
<h3 id="BlockTable">Block Table</h3>
<p>
The component called <em>block table</em> is 
responsible to map addresses to blocks according to the concept explained in Section <a href="#AddressResolution">Address Resolution</a>). 
Internally, the block table sorts all blocks by their base address to 
optimise lookup performance. To handle offheap areas transparently, the block table references 
a set of block tables, which contain the blocks of those offheap areas.
</p>

<h3 id="BlockList">Block List</h3>
<p>
Blocks in a Blender file follow a specific order, as explained in Section <a href="#BlockOrder">Block Order</a>.
Since the block table reorders blocks according to their base address, 
the <em>block list</em> was added to keep track of the sequential 
order required in a Blender file. Internally, the block list maintains a 
linked list of blocks to allow fast insertion or removal of blocks. 
</p>

<h3 id="Allocator">Allocator</h3>
<p>
Blocks of one Blender file establish a virtual memory space based on
blocks original address and size (cf. <a href="#AddressMapping">Address Mapping</a>). 
Especially when adding content to an existing or new Blender file, 
low level I/O has to keep track of allocated and free memory in respect 
to existing blocks. When inserting new blocks, the low level I/O has to check, where
this new block can be placed in this virtual memory space.
</p>
<p>
The allocator is assigned to the block table and is responsible to keep
track of the virtual memory space of the associated Blender files 
in terms of free and allocated memory regions. The allocator is not 
responsible to actually allocate memory in the JVM. This is a task 
of the block table. The allocator just finds free address space for
a new block or removes address space from its internal list of allocated 
regions.
</p>
<h3 id="MetaData">Meta Data Representation</h3>
Meta data (type information) of a Blender file is available in 
three different formats: <code>StructDNA</code>, <code>BlendModel</code> and <code>CMetaModel</code>.

<h4 id="StructDNA">StructDNA</h4>
The class <code>StructDNA</code>, which is an exact replica of the file content in block 
<code>"DNA1"</code> (see Section <a href="#DNATypeInformation">Type Information</a>),
provides no higher functionalities, such as lookup of types.
<h4 id="BlendModel">BlendModel</h4>
The class <code>BlendModel</code> basically contains the same information as 
<code>StructDNA</code>, but provides lookup capabilities.
<h4 id="CMetaModel">CMetaModel</h4>
The class <code>CMetaModel</code>, provides an enriched meta model which contains 
classification of types (such as pointer, array, scalar, struct) and 
detailed break downs of types into their base types (see class documentation for more information).

<h2 id="TypeMapping">Type Mapping</h2>
<p>
This section provides a specification of the type mapping of 
C types used in Blender files to Java types, as used in Java .Blend.
</p>
<h3>Scalar Types</h3>
<p>
The following table contains mappings of all scalar types 
in Blender files (C) to Java. 
</p>
<table border="1">
<tr>
  <th>C</th><th>native size [bytes]</th><th>Java</th>
</tr>
<tr>
  <td>char</td><td>1</td><td>byte</td>
</tr>
<tr>
  <td>short</td><td>2</td><td>short</td>
</tr>
<tr>
  <td>ushort</td><td>2</td><td>short</td>
</tr>
<tr>
  <td>int</td><td>4</td><td>int</td>
</tr>
<tr>
  <td>unsigned int</td><td>4</td><td>int</td>
</tr>
<tr>
  <td>float</td><td>4</td><td>float</td>
</tr>
<tr>
  <td>double</td><td>8</td><td>float</td>
</tr>
<tr>
  <td>long</td><td>4/8</td><td>long</td>
</tr>
<tr>
  <td>ulong</td><td>4/8</td><td>long</td>
</tr>
<tr>
  <td>int64_t</td><td>8</td><td>long</td>
</tr>
<tr>
  <td>uint64_t</td><td>8</td><td>long</td>
</tr>
<tr>
  <td><em>pointers</em></td><td>4/8</td><td>long</td>
</tr>
</table>

<h4>Signed and Unsigned Integer Types</h4>
<p>
Java does not support unsigned integer types. Thus,
every unsigned type is mapped to its signed counterpart. This 
has to be considered in case of overflows. 
</p>
<h4>32 and 64 bit Systems</h4>
<p>
In C, the size of pointers and the scalar types 
long and unsigned long depend on the system architecture: 
8 byte on 64 bit systems and 4 byte on 32 bit systems. 
Both are mapped to 64 bit in Java .Blend.
</p>
<h3>Structured Types</h3>
<p>
Based on the given type information from StructDNA, the model 
generator maps all structured types to Java facade classes. For 
each field of a struct a getter and setter method is generated
based on type and name of the field.
</p>


<h4>Embedded Structs</h4>
<p>
If a field of a struct is of a structured type (not a pointer)
then it is embedded in the struct in C. Those fields get 
represented by a facade of the fields type. The facade returned by
the corresponding getter method provides access to the embedded 
struct. When assigning another object (i.e. facade) to the field 
through its set method, the value of that object is copied into 
the memory region of the embedded struct. This is exactly the
same behaviour as in C.
</p>
<h3>Pointers</h3>
<p>
Pointers in C can refer to different kinds of data which has to
be known to understand the mapping chosen here. Generally, a 
pointer can be interpreted as a reference on a single data 
object or an array of data objects. 
</p>
<pre>
	/* pointer on single elem */
	int i;
	int* pi = &i;
	// same output from both printf statments
	printf("%d", *pi);
	printf("%d", pi[0]);
	
	/* pointer on array of elems */
	int a[] = {1,2,3};
	int* pa = a;
	// same output from both printf statments
	printf("%d", pa[1]);
	printf("%d", *(pa+1));
</pre>
<p>
This small example displays a couple of issues for type mapping of 
pointers to Java. Java builtin types can only deal with a few of 
the functionalities provided by a pointer, such as arrays of fixed 
length or references on objects. Often in C a pointer is used as reference on a set of elements in
an array, which ends with one specific terminating element, such as a null value. 
Every string in C is stored that way. To access its data you have 
to iterate through the array and scan for the terminating element. The only case 
you can scan through data in Java using builtin types, is that you have an 
array. Unfortunately, to create an array, you first need its length, 
that means you can't solve it without native access to data. Another issue is, 
that scalar types such as int, float, etc., cannot be referenced. 
Additionally, the corresponding class types such as <code>Integer</code> and 
<code>Float</code> are immutable (same for String), which means you 
cannot modify their value but assign a new instance to a reference. 
Hence, it is not the same if you have a reference on an 
object of type Integer in Java or an <code>int*</code> pointer in C.
</p>
<p>
Another case are type casts applied to pointers. In C it is possible 
to cast memory to any type. Best example are <code>void*</code> pointers
which have to be casted to a specific type when used.
Unfortunately, due to historical reasons, some pointers in Blender 
data imply a cast to a 
pointer of a structure of entirely different kind then the actual 
struct at the referenced address. Java supports casts as long as
the target object contains the class of the reference somewhere in the
inheritance hierarchy and the reference points to the base of the 
object (not somewhere inside). But in some of those cases in Blender files, the
members (fields) of the struct which is referenced by a pointer of different 
type are also different. This results in the fact, that we can't just 
map those pointers to base classes or interfaces of the target class. 
The referenced data has to be interpreted differently based on the new type.
</p>
<p>
This brief discussion of the different functionalities of a pointer in C
shows that it is not possible to map a pointer type to a particular Java
builtin type without semantic knowledge about its use case. But the developer
using the pointer can easily determin its use case and just needs a suitable
interface which supports all the functions of a C pointer in Java. In order to 
keep the data model generic Java .Blend introduces a <code>CPointer&lt;T&gt;</code> 
template class to solve all those issues. A consequence of this design 
decision is, that a pointer representation needs native data to operate 
on (e.g. to perform type casts etc.). This also drove the fundamental 
decision to keep data in memory and use facades instead of converting 
all data in Java types, once it is read.
</p>
<h4>Class <code>CPointer&lt;T&gt;</code></h4>
<p>This class supports all functionalities of a C pointer. The template 
parameter specifies its target type, which means the type of data the pointer
refers to. The target type can be either a scalar, an object (i.e. facade)
or a pointer again (pointer of pointer).
</p>
<p>
The following list gives an overview of its functionalities:
</p>
<ul>
<li>Get or set referenced element/object</li>
<li>Get or set its address</li>
<li>Iterate over referenced elements</li>
<li>Convert to array of fixed length</li>
<li>Convert to String of given length</li>
<li>Type cast to a pointer of a different type</li>
</ul>
<p><em>For more details refer to source code documentation.</em></p>
<h3>Arrays</h3>
<p>
Driven by the design decision on pointers, all data is kept in its native format
in heap memory. This means, although we could map arrays of fixed length to 
their Java counter parts, it would be inconsistent. Instead arrays are represented by
facades of type <code>CArrayFacade&lt;T&gt;</code> class templates where the template parameter 
<code>T</code> specifies the type of its components. Multi-dimensional arrays 
simply have a component type which is an array 
(e.g. <code>CArrayFacade&lt;CArrayFacade&lt;T&gt;&gt;</code>). <code>CArrayFacade&lt;T&gt;</code> 
is derived from <code>CPointer&lt;T&gt;</code> and inherits all its functionalities. 
Thus, arrays are pointers too, as in C.
</p>
<p>
The following list gives an overview of its functionalities:
</p>
<ul>
<li>Get or set elements of the array</li>
<li>Iterate over referenced elements</li>
<li>Pointer arithmetics</li>
<li>Type casting</li>
<li>Conversion filling from and conversion to Java built-in array types</li>
<li>Conversion between String and array</li>
</ul>



<h2 id="CodeGenerator">Code Generator</h2>
<p>
The code generation framework is responsible to generate classes based 
on the specified type mapping.
</p>
<p>
The entire code generator is located in package <code>org.cakelab.blender.generator</code>
Main class of the code generator is the class <code>ModelGenerator</code>.
</p>
<p>
Basic procedure of the code generator is to enumerate all structs specified in
the meta data received from a Blender file and forward it to a facade class generator. 
The code generator uses the documentation provider to retrieve JavaDoc 
documentation for members of generated facade classes.
</p>
<p>
When requested, the code generator also generates the <a href="#Utilities">utilities package</a> with 
<a href="#BlenderFactory">Blender Factory</a> and class <a href="#MainLib">MainLib</a>.
</p>

<h2 id="Facades">Generated Facade Classes</h2>
<p>
Main output of the code generator is the package with generated facade classes. 
Each generated class corresponds to one C structure specified in 
<a href="#StructDNA">StructDNA</a> with the same name, except of <code>struct Object</code>
which was renamed to <code>BlenderObject</code>. 
</p>
<p>
Instances of facade classes are assigned to their respective block and provide getter 
and setter methods to access the member variables of the struct inside the block. Access
to data involves conversion between data representation in the block and data representation
in Java. This conversion is handled transparently on demand by the data I/O subsystem.
</p>


<h2 id="Utilities">Generated Utilities Package</h2>
<p>
The optional utilities package contains code generated by 
the <a href="#CodeGenerator">code generator</a>. It contains Blender version 
specific code which helps in lookup (see <a href="#MainLib"><code>MainLib</code></a>) 
of specific data in a Blender file and creation of blocks (see <a href="#BlenderFactory"><code>BlenderFactory</code></a>).
</p>
<h3 id="MainLib">Main Library</h3>
<p>
Data in a Blender file is subdivided in main library elements, such as scenes, configuration data,
objects, meshes, material, etc., and data associated to them such as vertices, loops, edges, normals, etc.
The class <code>MainLib</code> provides references to all main library elements.
</p>
<h3 id="BlenderFactory">Blender Factory</h3>
<p>
Adding data to Blender files is not an easy task. The class <code>BlenderFactory</code> helps in this task in various ways. 
</p>
<ul>
<li>
It provides factory methods to create blocks with assigned instances of facades, pointers 
or arrays (i.e. structs or raw data). 
</li>
<li>
It establishes a <a href="#BlockList">block list</a> based on the sequence of instantiations performed
at its factory methods. 
</li>
<li>
It instantiates a version specific but encoding independent <a href="#StructDNA">StructDNA</a> 
needed to create new files. 
</li>
</ul>

<h2 id="Documentation">Externally Maintained Documentation</h2>
<p>
Javadoc documentation of the generated facade classes is retrieved through a 
documentation provider from external documentation files. Those documentation
files contain a list of structs and their members with associated 
documentation.
</p>
<p>
<em>
Please note that the DNA documentation is kept in a <a href="https://github.com/homacs/org.cakelab.blender.dnadoc.git">
repository on github</a> and published under 
GPL v3 (see Section <a href="index.html#Licensing">'Licensing'</a> on the main page for reasons).
</em>
<p>
Currently available documentation is extracted from Blender's source code via doxygen
and from it's Python API via script <code>rna_info.py</code>. Since this documentation
is still incomplete for the most parts, users can add more documentation manually in 
terms of files of the documentation system.
</p>
<p>
This section will explain the format of the documentation.
</p>
<!-- TODO: inheritance -->
<!-- TODO: javadoc/html and NL -->
<h3 id="DocumentationSystem">Documentation System</h3>
<p>This section specifies file format and folder layout of the documentation system.</p>
<h4 id="DocFileFormat">File Format</h4>
<p>
Documenation files are written in JSON and contain Javadoc comments. The following table will explain its contents.
</p>
<table border="1">
<tr><th>key</th><th>value</th><th>type</th><th>description</th></tr>
<tr><th>system</th><td>"Blender"</td><td>String</td><td>Always "Blender".</td></tr>
<tr><th>module</th><td>"DNA"</td><td>String</td><td>Always "DNA".</td></tr>
<tr><th>version</th><td>major.minor</td><td>String</td><td>Version string as retrieved from file header (e.g. "2.69")</td></tr>
<tr><th><b>source</th><td>source of information</td><td>String</td><td>String which specifies where this information was gathered from (e.g. Python API, Blender Source Code, etc.)</td></tr>
<tr><th>inherits</th><td>list of doc files to be inherited</td><td>Array of Strings</td><td>List of paths to doc files to be referred to, in case no other documentation was found for a given subject (e.g. struct). Inherited documentation will be overridden by included documentation or documentation found in the given doc file.</td></tr>
<tr><th>includes</th><td>list of files to be included</td><td>Array of Strings</td><td>List of paths to doc files to be included in this documentation file. This will override previously inherited or included documentation.</td></tr>
<tr><th>doc</th><td>Reserved for javadoc package info (e.g. package.html)</td><td>String</td><td>Place for package documentation which is not used in the current version.</td></tr>
<tr><th>structs</th><td>list of structs</td><td>Array of JSON objects</td><td>List of structs with documentation.
	<table border="1">
	<tr><th>key</th><th>value</th><th>type</th><th>description</th></tr>
	<tr><td><em>struct name</em></td><td>javadocs for a struct</td><td>JSON object</td><td>Contains javadoc for the corresponding class and its members.
		<table border="1">
		<tr><th>key</th><th>value</th><th>type</th><th>description</th></tr>
		<tr><td>doc</td><td>class doc</td><td>String</td><td>Class documentation.
		</td></tr>
		<tr><td>fields</td><td>docs for each field</td><td>JSON object</td><td>For each field:
			<table border="1">
			<tr><th>key</th><th>value</th><th>type</th><th>description</th></tr>
			<tr><td><em>field name</em></td><td>field doc</td><td>String</td><td>Javadoc for a specific field.
			</td></tr>
			</table>
		</td></tr>
		</table>
	</td></tr>
	</table>
</td>
</tr>
</table>
<p>
All elements which contain Javadoc comments (i.e. all properties with key <code>'doc'</code>) contain text
only. That means, no slashes or stars like '/**' or '*/'. Since Javadoc accepts HTML complex constructs, 
like tables or lists can be added with HTML code.
</p>
<h4 id="DocFolderLayout">Folder Layout and Versioning</h4>
A documentation folder consists of the following subfolders:
<ul>
<li><code>dnadoc</code> Main folder of the DNA documentation.
  <ul>
  <li><code>&lt;majorVer.minorVer&gt;</code> Version subfolder (e.g. <code>2.69</code>).
    <ul>
    <li><code>dnasrc</code> Documentation retrieved from Blender source code via doxygen.
    <ul>
    	<li><code>doc.json</code> Documentation entry file.</li>
    </ul>
    </li>
    <li><code>pyapi</code> Documentation retrieved from Blender's Python API source code via script <code>rna_info.py</code>.
    <ul>
    	<li><code>doc.json</code> Documentation entry file.</li>
    </ul>
    </li>
    <li><code>added</code> Manually added documentation.
    <ul>
    	<li><code>doc.json</code> Documentation entry file.</li>
    	<li><code>DNA_ID.json</code> Documentation for all structs in <code>DNA_ID.h</code></li>
    	<li><code>DNA_object_types.json</code> Documentation for all structs in file <code>DNA_object_types.h</code></li>
    </ul>
    </li>
    </ul>
  </li>
  <li>..</li>
  </ul>
</li>
</ul>



<h3 id="DocumentationProvider">Documentation Provider</h3>
<p>
Documentation provider is an interface providing lookup of 
documentation stored in files of the documentation system.
The documentation provider automatically searches the most 
appropriate documentation for a given Blender file version
combination (i.e. <code>MINVERSION</code> and <code>VERSION</code> 
and their respective extensions (subversions)). 
</p>
<p>
Since there are multiple sources of documentation (i.e. 
Python API, Blender Source Code and manually added ("Java .Blend")) 
the documentation provider combines them in a list of documentation 
entries where each source gets its own section.
</p>
<h1 id="GettingStarted">Getting Started</h1>
<p>
This is a brief getting started guide for Java .Blend API programmers.
It covers just the basic tasks such as setting up 
the development environment, and reading or writing Blender files
with help of the class <a href="#BlenderFactory"><code>BlenderFactory</code></a>.
</p>
<p>
To give a more detailed view on Java .Blend, all of its features 
have been demonstrated in examples which can be found in the 
<a href="http://homac.cakelab.org/projects/JavaBlend/index.html#download">download section on the Java .Blend website</a>.
</p>
<h2 id="Setup">Setup</h2>
<p>
As explained in the concept overview, working with Java .Blend 
requires a set of facade classes and utilities which are 
generated by the code generator. You can either use
a pregenerated Java archive of the <a href="http://homac.cakelab.org/projects/JavaBlend">download section</a> or run the code 
generator on your own (see Section <a href="#GeneratingCode">Generating Data Model and Utilities</a>). 
The latter case is necessary if there is either no pregenerated 
Java archive available for your Blender version or you 
decided to work on code generator or documentation.
</p>
<p>
To get running, add the jar of the pregenerated data model to your project:
</p>
<ul>
<li><code>JavaBlend-&lt;version&gt;-DNA-&lt;blender-version&gt;.jar</code></li>
</ul>

<h2 id="Reading">Reading</h2>
<p>
There is an easy way and a more complex but even more flexible way to read Blender files.
The easiest way is to use the class <code>MainLib</code> and the more complex involves 
direct access to blocks.
</p>
<h3>Access Through Class <code>MainLib</code></h3>
<ul>
<li>Open the file by instantiating an object of class <a href="#BlenderFile"><code>BlenderFile</code></a>.</li>
<li>Provide the open file to the constructor of MainLib.</li>  
</ul>
<p>
Class <code>MainLib</code> provides access to all library elements found in the file and those provide access
to the remaining raw data through its getter methods.
</p>
<h4>Example</h4>
<pre>
	BlenderFile f = new BlenderFile(new File(filename));
	MainLib lib = new MainLib(f);
	f.close();                 // all data was read by MainLib constructor

	Mesh mesh = lib.getMesh(); // access mesh
</pre>
<h3>Reading with Direct Block Access</h3>
<p>
Reading with direct block access basically involves opening a Blender file, retrieve/search blocks, 
instantiate appropriate facade classes based on the type information (sdnaIndex) given in the 
block and finally access it. See example class <code>ExampleConvert2Json</code> for a comprehensive 
example on direct block access including meta data lookup etc.
</p>

<h2 id="Writing">Writing</h2>
<p>Creating or extending Blender files requires a lot of knowledge on the 
Blender data model. Unfortunately, the data model is quite huge and contains lots of
references between elements and redundant information too. The best way to 
gather information on how to write a Blender file, is to study one first and use it as template.
</p>
<p>
As part of the examples, you will find a class called <code>ExampleConvert2Json</code>, which creates a JSON
file with all information of a Blender file in the given block order. This file 
is quite easy to read and helps a lot in studying the Blender DNA.
</p>
<p>
Additionally, you will need to download the Blender sources and open the folder 
<code>source/blender/makesdna</code>.
There, you will find various C header files with the prefix <code>DNA_</code>. 
Those header files contain all types (structs) of the Blender DNA (i.e. all 
types that can possibly exist in a Blender file). When not sure about the 
meaning of a member variable of a struct, then look if there is source code 
documentation and if you have an IDE which supports function call lookup etc. (i.e. Eclipse), 
then use it to find contexts in which this member variable is accessed.
</p>
<p>
The example <code>CopybufferExchange</code> provides a full example on how to create 
a Blender file for exchange via the clipboard functionality of Blender.
</p>

<h2 id="ContributeDoc">Contributing to Documentation</h2>
<p>
As mentioned, the documentation on the generated facade 
classes is still poor and programmers will need to read Blenders source code
and study <code>.blend</code> files to gather more information. 
To speed things up, everybody is encouraged to contribute to the externally
maintained documentation. This is not just about helping others, it is more about helping
<em>each other</em> in terms of a <b>team effort</b>! If we all study the 
Blender source code for ourselves, we waste a tremendous 
amount of work power, trying to find knowledge over and over again,
someone else already figured out! Just do the math.
</p>
<p>
The DNA documentation is also available on github. Its URL is:
</p>
<p><a href="https://github.com/homacs/org.cakelab.blender.dnadoc.git"><code>https://github.com/homacs/org.cakelab.blender.dnadoc.git</code></a><p>
<p>
To contribute to the documentation just fork it on github, and send me a 
pull request with your modifications. Contributions are reviewed and 
incorporate on a regular basis.
</p>
<p>
The format of the documentation is explained in Section 
<a href="#Documentation">Externally Maintained Documentation</a>. 
Please check your modifications by performing a code generation run (see Section <a href="#GeneratingCode">Generating Data Model and Utilities</a>). 
</p>

<h2 id="GeneratingCode">Generating Data Model and Utilities</h2>
<p>
This section explains how to generate Java .Blend
facade classes and utilities for a given Blender version. 
This procedure is 'almost' generic. In case you experience issues, 
then read the Section <a href="#Troubleshooting">Troubleshooting</a> below. 
</p>
<p>
The generated code is subdivided into two packages:
</p>
<ul>
<li>The <a href="#Facades">facade classes</a></li>
<li>The <a href="#Utilities">utilities package</a></li>
</ul>
<p>
The utilities package is slightly more version dependent than 
the facade classes. That means, the code generator may 
generate an incompatible utilities package in future versions 
of Blender while the facade classes will most certainly remain
compatible and working. Therefore, the generation of the 
utilities package is optional.
</p>
<p>
In order to generate the facade classes you need a <code>.blend</code>
file saved with the version of Blender you are aiming to support 
as reference. This can be any <code>.blend</code>
file and even the user preferences to be found in 
<code>$HOME/.config/blender/2.69/config/userpref.blend</code>.
</p>
<p>
In order to incorporate Javadoc comments in the generated 
facade classes you need to download a set of Java .Blend's 
external documentation files either directly from the 
<a href="">github repository</a> or the <a href="http://homac.cakelab.org/projects/JavaBlend#download">download section of Java .Blend's website</a>. 
Please note, that you have to respect the license of the 
documentation files if you plan to redistribute derived work. 
Please refer to Section <a href="index.html#Licensing">'Licensing'</a> 
on the index page to learn more about the reasons.
</p>
<h3>Command Line Parameters</h3>
<p>
The code generator gets started from command line.
</p>
<pre>
	java -jar JavaBlend-SDK-&lt;version&gt;.jar &lt;options&gt;
</pre>
<p>
Alternatively, you can use the Ant build file <code>export-DNA-lib.xml</code> and modify it to
adjust it to your environment. 
</p>
<table>
<tr><th>name</th><th>type</th><th>default</th><th>description</th></tr>
<tr><td>-in</td><td>path</td><td></td><td>Blender file (always containing type information) to use as reference.</td></tr>
<tr><td>-out</td><td>path</td><td></td><td>Source code folder to create the package and store the generated classes.</td></tr>
<tr><td>-p</td><td>Java package name</td><td>"org.cakelab.blender"</td><td>Main package of generated code. Facades will go in subpackage 'dna' and utilities in 'utils'.</td></tr>
<tr><td>-u</td><td>boolean</td><td>true</td><td>Enable (true) or disable (false) generation of utilities package.</td></tr>
<tr><td>-c</td><td>path</td><td>"resources/dnadoc"</td><td>Main folder of the documentation system. This is optional. 
					If no documentation is found, the code generator will still generate all code.</td></tr>
<tr><td>-d</td><td>boolean</td><td>true</td><td>Enable (true) or disable (false) debug output. It's currently used by the documentation system only.</td></tr>
<tr><td>-h</td><td></td><td></td><td>Prints brief help message and exits without code generation.</td></tr>
</table>
<h3>Example</h3>
<pre>
	> java -jar JavaBlend-SDK-1.0.0.jar -in "$HOME/.config/blender/2.69/config/userpref.blend" -out "../MyProject/src"
</pre>
<p>
As you see, you can even use the user preferences file as reference <code>.blend</code> file to provide the type information needed to 
generate the code.
</p>
<h3 id="Troubleshooting">Troubleshooting</h3>
<dl>
<dt>Exception due to Overlapping Blocks</dt>
<dd>Overlapping blocks occur if the generated data model does not have a full list of possibly existing 
	<a href="#OffheapAreas">offheap areas</a>. To fix this issue on your own, you need add an 
	entry to the list of offheap areas and rerun the data model generator (API will be the same as before). 
	However, it would be nice, if you can tell me about the issue, so I can fix it for everybody.</dd>
</dl>
</body>
</html>